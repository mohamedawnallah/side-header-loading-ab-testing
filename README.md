# Side-Header Loading A/B Testing Experiments
This repository serves as a knowledge base documenting my A/B testing experiments. Here, I explore and evaluate various hypotheses, recording methodologies, results, and insights gained throughout the process.

## Hypotheses Regarding `filters_db/header-index`, `block_headers_bin`, and Filter Headers

| #  | Block Header in `filters_db/header-index/<16bit_prefix>/block_hashes_group` | Block Header in `block_headers_bin` | Filter Header in `reg_filter_headers_bin` | **Updating Bitcoin Tip (Manually)** | **Updating Regular Tip (Manually)** | Description | Variables | Default Outcome (`Hâ‚€`) | Accepted or Rejected |
|----|:----------------------------------------:|:-----------------------------------:|:-----------------------------------------:|:-----------------------------------:|:-----------------------------------:|:------------|:----------|:----------------------|:---------------------:|
| 1  | âœ”ï¸                                       | âŒ                                  | âŒ                                      | âŒ                                  | âŒ                                  | Block Header exists in `filters_db/header-index` but not in `block_headers_bin` | â€“ | Error creating chain service: unable to read block header: `EOF` | Accepted            |
| 2  | âŒ                                       | âœ”ï¸                                  | âŒ                                      | âŒ                                  | âŒ                                  | Block Header not in `filters_db/header-index` but exists in `block_headers_bin` | â€“ | Error creating chain service: target height not found in index  | Accepted            |
| 3  | âŒ                                       | âŒ                                  | âŒ                                      | âŒ                                  | âŒ                                  | Removing Tail Block Header from both stores | Not updating chain tip for both btc and regular header | Error creating chain service: target height not found in index | Accepted            |
| 4  | âŒ                                       | âŒ                                  | âŒ                                      | âœ”ï¸                                  | âŒ                                  | Removing Tail Block Header from both stores | Updating chain tip for btc only and not regular header | Error creating chain service: target height not found in index | Accepted            |
| 5  | âŒ                                       | âŒ                                  | âŒ                                      | âœ”ï¸                                  | âœ”ï¸                                  | Removing Tail Block Header from both stores | Updating chain tips for btc and regular header | `OK` | Accepted            |
| 6  | âŒ                                       | âŒ                                  | âœ”ï¸                                      | âŒ                                   | âŒ                                  | Removing Head Block Header from both stores | Not Removing Filter Header from store | Error creating chain service: unable to read block header: EOF | Accepted                     |
| 7  | âŒ                                       | âŒ                                  | âŒ                                      | âŒ                                    | âŒ                                    | Removing Head Block Header from both stores | Removing Filter Header from store | Error creating chain service: unable to read block header: EOF | Accepted                    |
| 8  | âŒ                                       | âŒ                                  | âŒ                                      | â€“                                   | â€“                                   | Removing Middle Header from both stores | Not Removing Filter Header from store | `OK` | â€“                     |
| 9 | âŒ                                       | âŒ                                  | âŒ                                      | â€“                                   | â€“                                   | Removing Middle Header from both stores | Removing Filter Header from store | `OK` and that Mid Filter header should be computed and indexed automatically | â€“                     |
| 10 | âœ”ï¸                                       | âœ”ï¸                                  | âŒ                                      | âŒ                                  | âŒ                                   | Removing Filter Header from store  | â€“ | Error creating chain service: unable to read filter header: EOF | Accepted                     |
| 11 | âœ”ï¸                                       | âœ”ï¸                                  | âœ”ï¸                                      | âŒ                                  | âŒ                                  | Header exists in both | â€“ | `OK` | Accepted            |

ğŸ“Œ **Note:** Block filters located in `filters_db/filter-store/regular/<block_hashes>` index are populated during a [`Rescan`](https://github.com/lightninglabs/neutrino?tab=readme-ov-file#rescan) only if the `PersistToDisk` configuration parameter is set to true (default: false) otherwise only the regular block filter tip exist.

ğŸ“Œ **Note to Self:** For simplicity and for now, letâ€™s ignore the block filter dimension in the index `filters_db/filter-store/regular/<block_hash>` during A/B testing.
We only need to ensure that the block hash value from the `header-index/regular` key is present as a key in the `filter-store/regular` index, with its value being the corresponding block filter which is variable in size. So this one-to-one mapping property needs(may be not?) to be maintained when side-header loading in case of best block header extended.

## Hypotheses Regarding Side Loading of Block AND Filter Headers

## Conclusions

1. **Permitted Operations:** The permitted operations for side-loading are limited to either no-operation (no-op) or extending. This enforces the monotonicity/append-only property, meaning the state can only remain the same or grow, but never decrease or revert. This restriction is based on mutual trust, as established in the merge intervals algorithm and the process of overlapping checkpointing.
2. **Conjunction Property:** When side-loading block headers for a given range (e.g., blocks M to N), the corresponding filter headers for the same range (M to N) must also be provided. The conjunction property requires that both block headers and filter headers for the specified range are present and valid. The semantic mapping between block headers and filter headers is assumed to be correct and trusted; however, syntactic validation may still be performed during side-loading to ensure structural correctness.
3. **Idempotence Propery:** The idempotence property ensures that performing the same side-loading operation multiple times has the same effect as performing it once. In other words, repeated application of a no-op or extending operation does not result in inconsistencies or unintended changes to the state.
4. **Atomicity Property:** The atomicity property guarantees that each side-loading operation is all-or-nothing: either the entire operation is applied successfully, or no part of it takes effect. This prevents partial application of data, which could result in inconsistencies or corruption.
5. **Chain Tip Consistency:** The chain tip for both `header-index/bitcoin` and `header-index/regular` must always be updated to the best block hash known whenever an extending side-load operation is performed. The value stored should be the double SHA256 (sha256d) of the raw block header data, represented in little-endian format. This ensures that all auxiliary indices and chain state reflect the latest, canonical tip and that downstream operations can reliably reference the most recent block.

## Rationale behind Conclusions

1. **Monotonicity/Append Only Property:** By explicitly disallowing replace, update, and delete operations, and limiting actions to no-op or extending, the system enforces the monotonicity/append-only propertyâ€”the state can only stay the same or grow. This greatly simplifies reasoning about system behavior and prevents inconsistencies or malicious rollbacks during side-loading. Relying on mutual trust and well-defined procedures (such as merge intervals and overlapping checkpointing) enables safe coordination of updates, while minimizing the attack surface and operational complexity.
2. **Conjunction Property for Consistency:**  Requiring both block headers and filter headers together enforces the conjunction property, ensuring data consistency and preventing partial or mismatched data from being introduced during side-loading. This maintains the integrity of the chain state and ensures that all necessary components are available for downstream processing or validation.
3. **Idempotence Propery for Fault Tolerance:** Enforcing the idempotence property means that side-loading operations can be safely retried or repeated without concern for corrupting or altering the intended state. This increases robustness and fault tolerance in distributed or unreliable environments, as repeated operations have no adverse side effects.
4. **Atomicity Property for Reliability:** Enforcing the atomicity property ensures that side-loading operations are applied in their entirety or not at all. For example, if an operation fails partwayâ€”such as only the block headers are written but not the filter headersâ€”the system should roll back or recover to a consistent state. This guarantees that the system never ends up in a partially updated or inconsistent state, preserving data integrity and reliability even in the case of errors or failures during the operation.
5. **Chain Tip Consistency for Canonical State:** By requiring that the chain tip in both `header-index/bitcoin` and `header-index/regular` always reflects the best block hash (computed as the double SHA256 of the raw block header in little-endian), the system guarantees that all key indices and lookups are synchronized with the actual state of the chain. This prevents ambiguity about the tipâ€™s identity, ensures fast and reliable tip discovery, and provides a single source of truth for downstream components. The tip **must be updated** on every extending side-load to avoid stale state and to uphold the guarantees of atomic consistency.
